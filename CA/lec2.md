
# Lecture 2-Performance

두번째 강의는 성능에 관한겁니다.

컴퓨터의 성능을 어떻게 평가할 수 있는가에 관한 내용입니다.

책의 1장 6절에 해당되는 내용이고 그 외에 1장 2절을 간단히 보고 지나가겠습니다.

# 1.2 8 Great Ideas in Computer Architecture



1장 2적의 제목은 컴퓨터 아키텍쳐에있어서 위대한 아이디어 라는 제목인데

컴퓨터 구조를 발전시켜온 아이디어 8개를 소개하고있습니다.

피카소 그림 (추상화)

## 1. Design for moore's Law

첫째는 무어의 법칙을 고려한 설계라고 보면되겠습니다.

무어의 법칙이라는것은 3년에 4배씩 증가한다 라는거죠.

그러니까 반도체 칩에 들어가는 트랜지스터의 개수가.

1.5년에 2배씩 증가한다. 인텔을 처음 만들었던 고든무어가 주장한 법칙입니다.

그 법칙이 최근까지도 굉장히 잘 맞아 떨어지고 있습니다.

그래서 지금 어떤 컴퓨터를 설계해서 시장에 내놓으려면 그것이 3년후에 4배 성능이 좋아질것이다

라는것을 고려해서 그것보다 나은 컴퓨터를 내놓아야 한다는거죠.

아,, 3년에 4배를 그래프로 그리면.

(그리면서 설명함)

그런데 y축을 로그스케일로, 그러니까 1, 2, 3, 4가 아니라 1, 2, 4, 8 이렇게 그리면

직선으로 우상향하는것이 됩니다.

이 무어의 법칙과 관련된 그림이 나올때는 그래서 이렇게 직선 우상향 그래프가 나올껍니다.

## 2. Use Abstraction to Simplify Design

설계를 단순하게 하기위해서 추상화를 이용한다.

여러분이 많이 들었겠고, 소프트웨어 공학과 관련된걸 배울때 또 들을겁니다.

처음부터 다 만들려고하면은 잘 되지않고,

처음에는 큰덩어리를 굵직하게 추상적으로하고, 그다음에 조금더 구체화하고, 이렇게해서

마지막에는 완전한 프로그램을 만드는것을 많이 하죠.

과거의 용어로는 stepwise refinement라고 했는데

단계적으로 좀더 구체화해나간다. 그래야 복잡한 설계를 다룰 수가 있습니다.

하드웨어 설계도 마찬가지다.

첫단계에서는 추상화해서 하고, 점점점 구체화해서 하는 그런방법.

## 3. Make the Common Case Fast

그다음 세번째. 

이건 나중에 나올 암달의 법칙과 관련이있는데.

자주 나오는 경우를 빠르게 해라.

이를테면, 100억을 들여서 도로 확장을하는데 하루에 차 100대 다니는길을 확장하는것보다

10000대 다니는 도로를 확장하는것이 더 도움이 되겠죠.

자주 사용되지 않는곳을 개선하는것은 컴퓨터 성능개선에 큰 도움이 되지않을것이다.

뭐 이런겁니다.

이건 책에 그림으로 스포츠카 그림으로 나올겁니다.

## 4. Performance via Parallelism

그다음 네번째.

4, 5, 6번째는 성능개선.

퍼포먼스라고 써있지만, performance improvement라고 생각하면되죠.

병렬성을 이용한 성능개선.

10개의 일을하는데 하나씩하면 10만큼 걸리겠지만 한번에 2개씩하면 5밖에 안걸려요.

컴퓨터에서도 마찬가지. 동시에 여러개를해서 성능을 높인다.

지금은 멀티코어라고하죠. 칩하나에 프로세서 여러개가 들어갑니다.

프로세서 4개가 들어가면 4개의 일을 동시에 할 수 있죠.

그러면 그만큼 시간이 단축된다.

이것은 그동안의 컴퓨터 성능을 개선하는데 큰 역할을 해왔습니다.

그리고 이 병렬성은 여러계층, 여러가지가 있습니다.

이 강의의 마지막부분에서 parallelism의 종류가 한번 나올껍니다.

그래서 이런 병렬성 성능개선부분이 나올때는 비행기 그림이 나올껀데

비행기의 엔진은 보통 하나가 아니고 여러개죠. 2개 또는 4개엔진이 동시에 작동을해서 더 빨리간다.

이것에 관련되는 기술이 나올때 책에서 비행기그림을 재시합니다.

## 5. Performance via Pipelining

파이프라이닝은 중간고사 끝나고나서 설명이 될겁니다.

찰리 채플린이 나오는영화에서 사람들이 쭉있고 한사람은 나사만돌리고 옆사람은 다른일하고

한사람이 똑같은일만하는데 쭉 지나가고나면 마지막에 제품이 완성됩니다.

그런데 한 단계에있는 사람은 똑같은 한가지 일만하죠.

컴퓨터에서 일을 처리하는데 있어서 마찬가지로 처리 단계를 여러개로 나눠놓고

각 단계가 독립적으로 동작하게해서 이를 처리하는것이 파이프라이닝입니다.

이 파이프라이닝을 이용해서 성능을 개선하는 그런 부분이 나오면 파이프 그림이 나오는게 되겠습니다.

## 6. Performance via prediction

그다음 예측을 이용한 성능계선.

어떤 일이 닥치기전에 예측을해서 준비를 해두면 그 일이 닥쳤을때 빨리 처리할 수 있죠.

컴퓨터에서 그런일이 자주 있습니다.

그럴때 마법서의 수정구슬 그림을 보여서 이런 기술이 적용되는 부분이다 라는것 표시합니다.

## 7. Hierarchy of Memories

메모리가 여러종류가 있습니다.

값이 싼메모리는 느리고, 비싼메모리는 빠르고.

그런데 값이 비싼 메모리로만 다 하면 좋겠지만, 비용을 생각하면 그럴수가 없습니다.

그래서 싼 메모리, 비싼 메모리를 적당히 잘 섞어서 이렇게 계층적으로 구성을하면

좋은 성능을 얻을 수 있다.

이거는 5장 전체가 그런내용입니다.

## 8. Dependability via Redundancy

그다음 redundancy를 이용한 dependability.

dependability라고 하는것은 컴퓨터가 생산해낸 결과를 믿을 수 있다. 신뢰할 수 있다 

뭐 reliability 비슷한거라고 볼수있겠습니다.

근데 어떻게 믿을 수 있는 결과를 내게 하느냐?

redundancy를 통해서. 

필요한것보다 더 많이 둠으로써.

실제 컴퓨터에 연산하는 장치가 하나만 있다고 한다면,

얘가 계산이 틀려도 알 수가 없습니다.

근데 연산장치를 3개를 두면 2개는 일치하는데 하나는 다르다.

그러면 하나가 고장났더라도 나머지 2개가 옳은 결과를 내니까 제대로된 결과를 낼 수 있습니다.

사실은 하나만 있으면 되는데 필요한것보다 더 많이 두는것 그것을 Redundancy라고 합니다.

이거는 큰 트럭 그림을 그렸는데.

이 트럭 바퀴를보면 바퀴가 2개씩 있지요. 

하나가 고장나더라도 나머지 하나가 있어서 계속 운행할 수 있다.

이게 Redundancy죠. 하나만 있어도 되는데 2개를 둔다.

책에서 8가지 하는데 사실 뭐 컴퓨터구조 역사상 위대한 발견 몇가지 라고 해서 더 구분한것을

다른책에보면 더 있습니다.

예를 들면, 캐시메모리라던지, 아키텍쳐와 오거니제이션의 분리라던지. 하는데

아무튼 우리책에서는 8가지를 하고.

뭐 별로 중요한 얘기는 아닙니다.

# 1.6 Performance

이제 제대로 성능 얘기를 해봅시다.

기본적으로 컴퓨터는 전자 장치죠. 전자 회로로 되어있습니다.

그 전자소자가 진공관이였다가 트랜지스터가 되고.

진공관 -> 트랜지스터 -> IC -> VLSI -> ULSI

뭐 IC이후에 이건 뭐 똑같은거죠. 집접도가 달라져서 칩하나에 트랜지스터가 더 많이 들어갔다

그건데 기본적으로 IC입니다.

성능을 가격으로 나눈값을 보면 ... 이렇게해서 

 - 진공관: 1
 - IC : 900
 - ULSI: 250,000,000,000

2500억배. 1951년보다 2013년에 2500억배 정도 좋아졌다.

어마어마 한거죠.

책에보면 그런 얘기가 있습니다. 항공산업, 운수산업이 이속도로 발전을 했다면, 

미국의 로스엔젤레스에서 뉴욕까지 몇초 안걸릴것이고. 비행기 요금도 몇달러 아닐것이다.

아까말한 무어의 법칙에 따라서 발전해 왔기 때문에 이런겁니다.

사실 무어의 법칙은 진공관때는 아니고 IC이후이긴 하지만.

밑의 그래프는 ~의 용량을 보여줍니다. (무어의 법칙 그래프)

아까 얘기한것처럼 이쪽은 linear scale이고 y축은 100배씩 뛰고 있지요.

이쪽(y축)이 로그 스케일이기 대문에 직선으로 보이는겁니다.

그런데, 다시 얘기를 하겠지만 이건 메모리 용량입니다.

메모리 용량은 3년에 4배씩 발전을 하고 있고.

CPU 프로세서의 성능도 뭐 거의 3년에 4배정도

그러니까 80년대 초반에는 1년에 ..정도 그러다 최근에는 20퍼센트 정도로 주춤하고 있는데

하여튼 프로세서는 굉장히 빠르게 성능이 개선되고 있습니다.

그러나 메모리는 용량은 무어의 법칙에 따라서 개선되고 있지만,

메모리 속도는 성능은 1년에 7퍼센트 밖에 좋아지고 있지 않습니다.

이게 문제지요.

cpu가 일을하려면 메모리에서 뭐를 가져와야하는데 이게 느리니까 발목을 잡죠.

그래서 과거에 memory wall, 메모리 장벽 이라는 용어를 썼습니다.

컴퓨터 성능이 좋아져서 앞으로 가려는데 메모리가 가로막아서 못나간다.

성능이 좋아지지 못한다. 그런 얘기죠.

메모리 크기는 좋아지지만 성능은 그러지 못한다. 이 얘기는 이제 메모리부분에서 다시 할겁니다.

이 문제를 해결해야하는데 어떻게 해결하느냐.

해결책도 5장에서 다시 보게 될거구요.

# Defining Performance

아 그러면 성능이라는게 도대체 뭐냐

어, 비행기의 경우를 예를 들겠습니다.

보잉 777, 보잉 747, 콩코드, 더글라스.

몇명을 태울 수 있느냐 그것도 성능이라고 볼 수 있겠죠.

얼마나 빨리 갈 수 있느냐 그것도 중요한 거겠죠.

빨리가는걸 본다면 콩코드가 좋을것이고 많이 싣는것을 고려하면 보잉 747이 좋겠죠.

근데 그걸 같이 고려해야 되겠죠.

그래서 passenger 하고 speed하고 곱한값을 하면 얼마나 빨리 얼마나 많은 사람을 실어 나를 수 있느냐

그게 되겠죠.

그래서 보잉 747이 제일 좋고 ... 이렇게 나옵니다.

근데 뭐 많은 사람을 실어날라야 한다면 이게 중요할 것이고, 조금만 실어서 빨리 가는게 중요하다면

저게 중요할 수 있는겁니다.

어떤 환경이냐, 목적이 뭐냐에 따라서 성능은 다르게 정의 될 수 있다.

그런데 공학에서는, 우리는 공학이니까.

우리과 이름이, computer science & engineering이니까.

사실은 engineering쪽이 더 많죠.

공학에서는 cost도 생각을 해야합니다.

무조건 성능이 좋다고 되는게 아니라 값이 비싸면 망한단말입니다.

콩코드 망했습니다. 콩코드 굉장히 비싸요.

이걸 같이 고려하려면 흔히 얘기하는 가성비죠.  cost/performance.

이거는 값이 작을수록 좋은겁니다.

가성비가 작은것이 좋은겁니다.

(... 비행기 그래프 얘기 ... 생략)

컴퓨터도 어떤 용도로 사용하느냐에 따라서 성능이 달라질 수 있고,

절대적 성능뿐 아니라 가격도 생각해야되고,

그렇다는 얘기를 하기위해서 비행기를 예를 들었습니다.

# Performance of a computer

- response time (=execution time)
 - The time between the start and completion of a task
- Throughput (= bnadwith)
 - The number of tasks completed per unit time
- Performance and execution time
 - Performance_x = 1 / Execution time_x
- X is n times faster than Y

그렇다면 컴퓨터의 성능을 어떻게 측정할 것이냐.

## Response time (=execution time)

어떤 프로그램을 돌렸는데 얼마나 빨리 결과가 나오느냐 그거가지고 얘기할 수 있겠죠.

결과가 빨리 나오면 좋은 컴퓨터입니다.

그래서 그 시간을 잽니다. 어떤 일을 시작해서 끝날때까지의 시간.

이것을 실행시간 혹은 응답시간이라고 합니다. responset time, execution time

## Throughput

여러분들이 sorting 프로그램 많이 짜봤을텐데.

sort 돌려서 결과가 빨리 나올수록 좋은거죠.

## Performance and execution time

그래서 실행시간과 성능은 반비례한다 라고 얘기할 수 있겠죠.

## X is n times faster than Y

x가 y보다 n배 빠르다는것은 x의 성능이 y성능의 n배이다. 그리고

성능과 실행시간은 역수관계니까

performance_x / performance_y = execution_time_y / execution_time_x = n

라는거죠.

그래서 혼자 자료구조 숙제하느라 sorting 프로그램 돌릴때는 이게 중요하지만

수강신청할때 학교 서버는 한사람만 잘해줘서 되는게 아니죠.

은행의 컴퓨터는 전국의 요구를 다 처리를 해줘야합니다. 그런때는

1초에 몇개의 작업을 처리하느냐가 중요한것이죠. 그것을 Throughput 또는 bandwidth라고 얘기합니다.

이 Bandwidth의 개념은 대역폭, 밴드의 폭이 넓냐 좁으냐 라는 개념인데. 넓으면 좋은겁니다.

이건 여러분이 전자공학 과목에서 low path filter, high path filter 하면서 밴드의 개념을 배웠을겁니다.

주파수를 이해해야 되는겁니다. 뭐 깊게는 얘기 안하겠습니다.

# Measuring Performance

그래서 성능을 어떻게 측정할것이냐.

## Defining of time

물론 실행시간을 따져야되는데. 그럼 시간은, 시간의 정의가 2가지가 있다.

### Wall-clock time = Response time = Elapsed time

wall-clock time, 벽시계 경과시간이라고 하는데.

어떤 작업을 하는데 걸린 전체시간입니다. 그니까 정렬프로그램 실행하는데 걸린 전체시간

그시간이 되겠죠. 그시간에 cpu processor가 처리하는시간 + 입출력 + 메모리 + os가 ..하는데 걸린시간

다 포함이 되죠.

이건 컴퓨터 시스템 전체가 사용되서 System performance라고도 합니다.

### CPU execution time = CPU time

그런데 cpu에대해서만 얘기하고 싶을때는 cpu execution time을 측정합니다.

내가 작성한 소팅프로그램을 위해서 cpu가 소비한 시간만 입니다. 이 response time의 일부분이겠죠.

메모리 엑세스타임, 입출력타임 이런것을 제외하고.

이 cpu time도 다시 2부분으로 나눌 수 있습니다.

내가 작성한 프로그램의 명령어, 기계어로 바꿔서 실행을 하긴 하지만

그 C문장을 실행하는데 걸리는 시간, user cpu time입니다.

근데 입출력은 사용자 프로그램이 하질 않죠. 운영체제를 불러서 처리를 합니다.

입출력 프로그램은 내 프로그램에 포함되지 않습니다.

그래서 내가 작성한 프로그램에 속한 명령어는 아니지만 내프로그램을 위해서 OS가 일한 시간은 System cpu time.

그래서 CPU Time = user cpu time + system cpu time.

당분간은 cpu performance 이것에 초점을 맞춰서 접근하도록 하겠습니다.

# CPU Clocking

모든 디지털기기들은 clock이 있습니다.

cpu도 물론 clock이 있습니다.

높은전압 낮은전압 반복을 하는데.

디지털기기의 모든일은 클럭주기로 진행이 됩니다.

예를들면 이 클럭 주기동안에, 데이터를 보내거나 계산을 하거나 하고, 클럭이 끝날때 업데이트를 합니다.

## Clock period = clock cycle time(CCT): duration of a clock cycle

이 클럭이 한 주기 동안에 걸리는 시간 clock cycle time 줄여서 CCT라고 표시하기도 합니다.

(... 수식 설명)

근데 우리가 cpu를 살때 보면 clock period 몇 피코다 이런 얘기 안하죠.

기가헤르츠 메가헤르츠를 말하는데 그것은 clock freequency (rate) 라고 하는겁니다.

## Clock frequency (rate) : cycles per second

이 클럭주기의 역수입니다. 

이건 초가 분모로 들어갑니다.

(... 수식 설명)

보통 clock rate를 사용합니다.

# CPU Performance and Its factors

```
CPU Time = CPU Clock Cycles * Clock Cycle Time
         = CPU Clock Cycles / Clock Rate
```

CPU TIme을 계산하는방법

(... 수식설명)

위에꺼 Clock Cycle Time 잘 안쓴다고 했죠

그래서 아래 Clock Rate로 나누는걸 씁니다.

그래서 ... 하면 성능이 좋아지고, ... 하면 성능이 낮아집니다. (수식으로 비례 반비례 당연한 얘기)

그런데 하드웨어 설계를 하다보면 이것들이 상관관계가 있다.

clock rate하고 cycle count(clock cycle 개수) 사이에 trade off가 있어서

이것을 줄이면 이것도 줄어든다, 이것을 늘이면 이것도 늘어난다 그런것이 있습니다.

그런데 프로그램 실행하는데 클럭사이클 몇개가 걸리느냐 이거 어떻게 아느냐.

이 클럭 레이트는 하드웨어 스펙에 있죠. 금방알수 있어요.

근데 내가 소팅프로그램 짜놓고 이거 몇클럭 걸릴까 바로 안나오죠.

# Instruction Performance

그래서 이거를 다시 쪼개서 생각해보면 2개 요소로 생각할 수 있다.

## Instruction Count (IC) for a program

첫째 이 프로그램 실행하는데 명령어 몇개를 실행하느냐.

그것을 Instruction Count, 명령어 몇개.

## Average Cycles Per Instruction (CPI)

그다음 명령어 하나 실행하는데 몇클럭 걸리느냐

이것 두개를 곱하면 나오겠죠?

이 프로그램 실행하는데 명령어 몇개를 실행했고, 

명령어 하나 실행하는데 평균적으로 클럭 몇개 걸렸고.

이 두개를 곱하면 됩니다.

## The Classic Cpu Performance Equation

```
CPU Time = IC * CPU * clock cycle time
         = (IC * CPI) / clock rate 
```

이게 이 lecture 2 의 가장 중요한 부분인 **CPU Performance Equation**입니다

CPU Time 은 IC * CPI * clock cycle time 또는 (IC * CPI) / clcok rate

오늘 렉쳐에서 가장 중요한 부분입니다.

### Instruction Count 에 영향을 주는 요소

그러면, Instruction Count(IC)는 무엇의 영향을 받느냐.

프로그램 짰는데 명령어 몇개 실행할것이냐.

이것은 프로그램을 어떻게 짯느냐, 알고리즘 어떻게 짯느냐, 그것의 영향을 받겠죠.

그리고 이건 지난시간에 했던 Instruction Set Architecture(ISA), 지난시간에 이 줄임말이 architecture라고 했었죠.

컴퓨터에서 어떤 명령어를 제공하느냐에 따라서 달라질 것이고, 컴파일러가 어떻게 번역하느냐에 따라서 달라질겁니다.

### Average Cycles Per Instruction (CPI)에 영향주는 요소

그다음 CPI는 CPU 하드웨어에 의해서 결정되죠.

이 컴퓨터가 더하기하는데 2클럭 걸리게 만들었는지 3클럭걸리게 만들었는지에 따라서 달라집니다.

그리고 많은경우에 명령어 종류에따라서 걸리는 클럭이 다릅니다.

어떤 명령어는 2클럭 걸리고, 어떤건 5클럭 걸리고 이렇게.

그래서 명령어 별로 CPI가 다르다면 이 Average CPI, 평균 CPI는 Instruction mix의 영향을 받는다.

Instruction mix라는것은 어떤 명령어가 몇퍼센트 실행되느냐 를 얘기하는 겁니다.

뒤에가서 자료도 한번 나오는데요. 어떤 명령어가 10퍼센트 다른명령어가 20퍼센트 실행되고 C가 30퍼센트.

통계를 내보면 명령어별로 실행빈도가 나오겠죠. 이걸 Instruction Mix라고 합니다. 

그거에 따라서 달라진다. 실행빈도를 가중치로 둬서 가중산술평균을 구해야되는거죠.

# 연습문제들

(..연습문제 설명, 해설함)

(이후 강의 생략..)
